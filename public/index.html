<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Angle</title>
    <link rel="icon" type="image/webp" href="/images/icon.webp">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://newsangle.co/">
    <meta property="og:title" content="Angle">
    <meta property="og:description" content="Stories worth listening.">
    <meta property="og:image" content="https://newsangle.co/api/og-image">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    
    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://newsangle.co/">
    <meta name="twitter:title" content="Angle">
    <meta name="twitter:description" content="Stories worth listening.">
    <meta name="twitter:image" content="https://newsangle.co/api/og-image">
    
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-RRQ8EPNMPQ"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-RRQ8EPNMPQ');
    </script>
    
    <style>
        @font-face {
            font-family: 'LTT Recoletta';
            src: url('/fonts/LttRecoleta-CmpRegular.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }
        
        @font-face {
            font-family: 'Berkeley Mono';
            src: url('/fonts/BerkeleyMono-Regular.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            overflow-x: hidden;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #1a1a1a;
            color: #ffffff;
            min-height: 100vh;
            padding: 0;
            margin: 0;
            overflow-x: hidden;
            width: 100%;
            max-width: 100vw;
        }

        .header-section {
            text-align: center;
            padding: 30px 20px 40px;
            max-width: 800px;
            margin: 0 auto;
        }

        .app-icon {
            width: 60px;
            height: 60px;
            margin: 0 auto 24px;
            display: block;
            border-radius: 18px;
        }

        h1 {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 16px;
            letter-spacing: -0.5px;
            line-height: 1.1;
        }

        .intro {
            font-size: 24px;
            color: #e0e0e0;
            margin-bottom: 20px;
            line-height: 1.4;
            font-weight: 400;
        }

        .filters {
            display: flex;
            justify-content: center;
            gap: 6px;
            padding: 20px 20px 30px;
            flex-wrap: nowrap !important;
            overflow-x: auto;
            overflow-y: hidden;
            max-width: 100%;
            width: 100%;
            margin: 0 auto;
            white-space: nowrap;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }

        .filters::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        .category-tag {
            white-space: nowrap;
            flex-shrink: 0;
        }

        .category-tag {
            padding: 5px 10px;
            border-radius: 4px;
            border: none;
            font-size: 10px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: 'Berkeley Mono', 'Courier New', Courier, monospace;
            background-color: #2a2a2a;
            color: #ffffff;
            cursor: pointer;
            transition: background-color 0.3s ease, opacity 0.3s ease, transform 0.2s ease;
        }

        .category-tag:hover {
            background-color: #3a3a3a;
            transform: translateY(-1px);
        }

        .category-tag.active {
            background-color: #ffffff;
            color: #000000;
        }

        .category-tag.inactive {
            opacity: 0.4;
        }

        .button {
            display: inline-block;
            background-color: #ffffff;
            color: #000000;
            text-decoration: none;
            padding: 12px 32px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 500;
            transition: background-color 0.2s ease;
            border: none;
            cursor: pointer;
        }

        .button:hover {
            background-color: #e0e0e0;
        }

        .button:active {
            background-color: #cccccc;
        }

        .gallery-wrapper {
            overflow: hidden;
            width: 100%;
            position: relative;
        }

        .collection-grid {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 20px 0 80px;
            width: max-content;
            will-change: transform;
        }


        .episode-card {
            position: relative;
            border-radius: 32px;
            overflow: hidden;
            background-color: #000000;
            cursor: pointer;
            transition: transform 0.2s ease, opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1), visibility 0.4s;
            width: 380px;
            height: 500px;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            opacity: 1;
            visibility: visible;
        }

        .episode-card.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .episode-card:hover {
            transform: scale(1.02);
        }

        .episode-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .episode-gradient {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 60%;
            background: linear-gradient(to top, rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 0.8) 40%, transparent 100%);
            pointer-events: none;
        }

        .episode-info {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 80%;
            padding: 36px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 1;
        }

        .episode-title {
            font-family: 'LTT Recoletta', Georgia, 'Times New Roman', serif;
            font-size: 36px;
            font-weight: 400;
            line-height: 1.05;
            color: #ffffff;
            margin: 0;
        }

        .episode-category {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: 'Berkeley Mono', 'Courier New', Courier, monospace;
            background-color: #2a2a2a;
            color: #ffffff;
            margin-top: 8px;
            align-self: flex-start;
        }

        .episode-description {
            font-family: 'Berkeley Mono', 'Courier New', Courier, monospace;
            font-size: 10px;
            line-height: 1.4;
            color: #ffffff;
            margin: 0;
            opacity: 0.9;
        }

        .episode-duration {
            font-family: 'Berkeley Mono', 'Courier New', Courier, monospace;
            font-size: 10px;
            line-height: 1.4;
            color: #ffffff;
            margin: 0;
            margin-top: 8px;
            opacity: 0.9;
        }

        .episode-date {
            font-family: 'Berkeley Mono', 'Courier New', Courier, monospace;
            font-size: 10px;
            line-height: 1.4;
            color: #ffffff;
            margin: 0;
            margin-top: 8px;
            opacity: 0.9;
        }

        .episode-host {
            font-family: 'Berkeley Mono', 'Courier New', Courier, monospace;
            font-size: 10px;
            line-height: 1.4;
            color: #ffffff;
            margin: 0;
            margin-top: 8px;
            opacity: 0.9;
        }

        #loadingSpinner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .loading {
            text-align: center;
            padding: 40px 20px;
            color: #b0b0b0;
            font-size: 16px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: #ffffff;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(8px);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            overflow-y: auto;
        }

        .modal-overlay.open {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            position: relative;
            background-color: #1a1a1a;
            border-radius: 32px;
            max-width: 900px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            transform: scale(0.95);
            transition: transform 0.3s ease;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .modal-overlay.open .modal-content {
            transform: scale(1);
        }

        .modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.1);
            border: none;
            color: #ffffff;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            transition: background-color 0.2s ease, transform 0.2s ease;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1;
        }

        .modal-close:hover {
            background-color: rgba(255, 255, 255, 0.2);
            transform: rotate(90deg);
        }

        .modal-close:active {
            transform: rotate(90deg) scale(0.95);
        }

        .modal-image {
            width: 100%;
            height: 400px;
            object-fit: cover;
            border-radius: 32px 32px 0 0;
            display: block;
        }

        .modal-body {
            padding: 40px;
        }

        .modal-category {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: 'Berkeley Mono', 'Courier New', Courier, monospace;
            background-color: #2a2a2a;
            color: #ffffff;
            margin-bottom: 20px;
        }

        .modal-title {
            font-family: 'LTT Recoletta', Georgia, 'Times New Roman', serif;
            font-size: 48px;
            font-weight: 400;
            line-height: 1.1;
            color: #ffffff;
            margin: 0 0 24px 0;
        }

        .modal-description {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            font-size: 16px;
            line-height: 1.6;
            color: #e0e0e0;
            margin: 0 0 24px 0;
        }

        .modal-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            margin-bottom: 24px;
            padding-bottom: 24px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-meta-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'Berkeley Mono', 'Courier New', Courier, monospace;
            font-size: 10px;
            color: #b0b0b0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .modal-meta-item strong {
            color: #ffffff;
            font-weight: 500;
        }

        .modal-date {
            font-family: 'Berkeley Mono', 'Courier New', Courier, monospace;
            font-size: 10px;
            color: #b0b0b0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 24px;
        }

        .modal-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 24px;
        }

        .modal-tag {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: 'Berkeley Mono', 'Courier New', Courier, monospace;
            background-color: rgba(255, 255, 255, 0.1);
            color: #ffffff;
        }

        .modal-audio-player {
            margin-top: 24px;
            padding: 20px;
            background-color: #2a2a2a;
            border-radius: 12px;
        }

        .audio-controls {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .audio-play-pause {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background-color: #ffffff;
            color: #000000;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            flex-shrink: 0;
            transition: background-color 0.2s ease, transform 0.2s ease;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .audio-play-pause:hover {
            background-color: #e0e0e0;
            transform: scale(1.05);
        }

        .audio-play-pause:active {
            transform: scale(0.95);
        }

        .audio-play-pause.playing {
            background-color: #ffffff;
        }

        .audio-progress-container {
            flex: 1;
            position: relative;
        }

        .audio-progress-bar {
            width: 100%;
            height: 4px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            cursor: pointer;
            position: relative;
        }

        .audio-progress-filled {
            height: 100%;
            background-color: #ffffff;
            border-radius: 2px;
            width: 0%;
            transition: width 0.1s linear;
        }

        .audio-progress-bar:hover .audio-progress-filled {
            background-color: #e0e0e0;
        }

        .audio-time {
            display: flex;
            align-items: center;
            gap: 4px;
            font-family: 'Berkeley Mono', 'Courier New', Courier, monospace;
            font-size: 12px;
            color: #b0b0b0;
            min-width: 100px;
            flex-shrink: 0;
        }

        .audio-time-current {
            color: #ffffff;
        }

        .audio-time-separator {
            color: #666666;
        }

        .audio-get-angle-btn {
            display: inline-block;
            background-color: #ffffff;
            color: #000000;
            text-decoration: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 500;
            transition: background-color 0.2s ease, transform 0.2s ease;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            flex-shrink: 0;
            white-space: nowrap;
        }

        .audio-get-angle-btn:hover {
            background-color: #e0e0e0;
            transform: translateY(-1px);
        }

        .audio-get-angle-btn:active {
            transform: translateY(0);
        }

        .audio-error {
            color: #ff6b6b;
            font-size: 12px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin-top: 12px;
            text-align: center;
        }

        .audio-loading {
            opacity: 0.6;
            pointer-events: none;
        }

        body.modal-open {
            overflow: hidden;
        }

        .modal-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 20px;
            z-index: 1002;
        }

        .modal-share-btn {
            padding: 8px 16px;
            border-radius: 8px;
            border: none;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.2s ease;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            pointer-events: auto;
            position: relative;
            z-index: 1003;
        }

        .modal-share-btn:hover {
            background-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .modal-share-btn:active {
            transform: translateY(0);
        }

        .share-toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #ffffff;
            color: #000000;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            z-index: 3000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .share-toast.show {
            opacity: 1;
            visibility: visible;
        }

        @media (max-width: 768px) {
            .modal-header {
                top: 15px;
                left: 15px;
                right: 15px;
            }

            .modal-share-btn {
                padding: 6px 12px;
                font-size: 12px;
            }
        }

        @media (max-width: 768px) {
            .header-section {
                padding: 20px 20px 30px;
            }

            .app-icon {
                width: 48px;
                height: 48px;
                margin-bottom: 20px;
            }

            h1 {
                font-size: 18px;
            }

            .intro {
                font-size: 20px;
                margin-bottom: 16px;
            }

            .button {
                padding: 10px 28px;
                font-size: 14px;
            }

            .filters {
                flex-wrap: nowrap !important;
                overflow-x: auto;
                overflow-y: hidden;
                padding: 15px 20px 20px;
                justify-content: flex-start;
                -webkit-overflow-scrolling: touch;
                white-space: nowrap;
                width: 100%;
            }

            .category-tag {
                white-space: nowrap;
                flex-shrink: 0;
            }

            .gallery-wrapper {
                width: 100vw;
                margin-left: calc(50% - 50vw);
                margin-right: calc(50% - 50vw);
            }

            .collection-grid {
                gap: 10px;
                padding: 15px 0 60px;
            }

            .episode-card {
                width: 340px;
                height: 450px;
            }

            .episode-title {
                font-size: 36px;
            }

            .episode-description {
                font-size: 10px;
            }

            .episode-info {
                padding: 28px;
            }

            .episode-gradient {
                height: 65%;
            }

            .modal-content {
                max-width: 100%;
                border-radius: 24px;
                max-height: 95vh;
            }

            .modal-close {
                top: 15px;
                right: 15px;
                width: 36px;
                height: 36px;
                font-size: 20px;
            }

            .modal-image {
                height: 300px;
                border-radius: 24px 24px 0 0;
            }

            .modal-body {
                padding: 28px 24px;
            }

            .modal-title {
                font-size: 36px;
                margin-bottom: 20px;
            }

            .modal-description {
                font-size: 14px;
                margin-bottom: 20px;
            }

            .modal-meta {
                gap: 12px;
                margin-bottom: 20px;
                padding-bottom: 20px;
            }

            .modal-audio-player {
                padding: 16px;
            }

            .audio-controls {
                flex-wrap: wrap;
                gap: 12px;
            }

            .audio-play-pause {
                width: 44px;
                height: 44px;
                font-size: 16px;
            }

            .audio-time {
                min-width: 80px;
                font-size: 11px;
            }

            .audio-get-angle-btn {
                padding: 8px 16px;
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <div class="header-section">
        <a href="/" class="header-link" id="headerLink" style="text-decoration: none; color: inherit; display: block;">
            <img src="/images/icon.webp" alt="Angle icon" class="app-icon">
        </a>
        <p class="intro">0 stories worth listening.</p>
        <a href="https://testflight.apple.com/join/p2VQgeun" class="button">Get Angle (Beta)</a>
    </div>
    <div class="filters" id="filters"></div>
    <div class="loading" id="loadingSpinner"><div class="spinner"></div></div>
    <div class="gallery-wrapper">
        <div class="collection-grid" id="collectionGrid">
        </div>
    </div>

    <!-- Story Detail Modal -->
    <div class="modal-overlay" id="storyModal">
        <div class="modal-content">
            <div class="modal-header">
                <button class="modal-share-btn" id="modalShareBtn" aria-label="Share episode">Share</button>
                <button class="modal-close" id="modalClose" aria-label="Close story">×</button>
            </div>
            <img class="modal-image" id="modalImage" src="" alt="">
            <div class="modal-body">
                <span class="modal-category" id="modalCategory"></span>
                <h2 class="modal-title" id="modalTitle"></h2>
                <div class="modal-meta" id="modalMeta"></div>
                <p class="modal-description" id="modalDescription"></p>
                <div class="modal-tags" id="modalTags"></div>
                <div class="modal-audio-player" id="modalAudioPlayer" style="display: none;">
                    <audio id="audioElement" preload="metadata"></audio>
                    <div class="audio-controls">
                        <button class="audio-play-pause" id="audioPlayPause" aria-label="Play audio">
                            <span class="play-icon">▶</span>
                            <span class="pause-icon" style="display: none;">⏸</span>
                        </button>
                        <div class="audio-progress-container">
                            <div class="audio-progress-bar" id="audioProgressBar">
                                <div class="audio-progress-filled" id="audioProgressFilled"></div>
                            </div>
                        </div>
                        <div class="audio-time">
                            <span class="audio-time-current" id="audioTimeCurrent">0:00</span>
                            <span class="audio-time-separator">/</span>
                            <span class="audio-time-duration" id="audioTimeDuration">0:00</span>
                        </div>
                        <a href="https://testflight.apple.com/join/p2VQgeun" class="audio-get-angle-btn" target="_blank" rel="noopener noreferrer">Get Angle</a>
                    </div>
                    <div class="audio-error" id="audioError" style="display: none;">
                        Unable to load audio. Please try again later.
                    </div>
                </div>
                <div class="modal-date" id="modalDate"></div>
            </div>
        </div>
    </div>

    
    <script>
        let episodes = [];
        let activeFilter = 'all';
        let animationFrameId = null;
        let scrollPosition = 0;
        let scrollSpeed = 15; // pixels per second
        let scrollDistance = 0;
        let lastTime = null;
        let currentAudio = null;
        let countAnimationId = null;
        let currentTargetCount = 0;
        let currentEpisodeId = null;

        // Shuffle array using Fisher-Yates algorithm
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Create episode card element
        function createEpisodeCard(episode) {
            const card = document.createElement('div');
            card.className = 'episode-card';
            card.setAttribute('data-category', episode.category || '');
            card.setAttribute('data-episode-id', episode.id);
            
            const dateText = episode.createdAt ? formatCardDate(episode.createdAt) : null;
            
            card.innerHTML = `
                <img src="${episode.coverImage || '/images/icon.webp'}" alt="${episode.title}" loading="lazy">
                <div class="episode-gradient"></div>
                <div class="episode-info">
                    <h3 class="episode-title">${episode.title}</h3>
                    <p class="episode-description">${episode.description || ''}</p>
                    ${episode.category ? `<span class="episode-category">${episode.category.toUpperCase()}</span>` : ''}
                    ${episode.host ? `<div class="episode-host">Host: ${episode.host}</div>` : ''}
                    ${dateText ? `<div class="episode-date">${dateText}</div>` : ''}
                </div>
            `;
            
            // Add click handler to open modal with URL update
            card.addEventListener('click', () => {
                openStoryModal(episode);
            });
            
            return card;
        }

        // Animation loop using requestAnimationFrame
        function animate(currentTime) {
            const grid = document.getElementById('collectionGrid');
            
            if (lastTime === null) {
                lastTime = currentTime;
            }
            
            const deltaTime = (currentTime - lastTime) / 1000; // Convert to seconds
            lastTime = currentTime;
            
            // Only animate if we have content
            if (scrollDistance > 0) {
                // Update scroll position
                scrollPosition += scrollSpeed * deltaTime;
                
                // Loop back when we've scrolled one set width
                if (scrollPosition >= scrollDistance) {
                    scrollPosition = scrollPosition % scrollDistance;
                }
                
                // Apply transform
                grid.style.transform = `translateX(-${scrollPosition}px)`;
            }
            
            // Continue animation
            animationFrameId = requestAnimationFrame(animate);
        }

        // Start animation
        function startAnimation() {
            if (animationFrameId === null) {
                lastTime = null;
                animationFrameId = requestAnimationFrame(animate);
            }
        }

        // Stop animation
        function stopAnimation() {
            if (animationFrameId !== null) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                lastTime = null;
            }
        }

        // Format date for display
        function formatDate(dateString) {
            const date = new Date(dateString);
            const options = { year: 'numeric', month: 'long', day: 'numeric' };
            return date.toLocaleDateString('en-US', options).toUpperCase();
        }

        // Format duration (in seconds) to readable format
        function formatDuration(seconds) {
            if (!seconds) return null;
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            
            if (hours > 0) {
                return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            return `${minutes}:${secs.toString().padStart(2, '0')}`;
        }

        // Format duration to minutes and seconds for card display
        function formatDurationMinutes(seconds) {
            if (!seconds) return null;
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${minutes}m ${secs}s`;
        }

        // Format date for card display (e.g., "Sun Jan 25")
        function formatCardDate(dateString) {
            if (!dateString) return null;
            const date = new Date(dateString);
            const options = { weekday: 'short', month: 'short', day: 'numeric' };
            return date.toLocaleDateString('en-US', options).replace(',', '');
        }

        // Format time for audio player (MM:SS or HH:MM:SS)
        function formatTime(seconds) {
            if (isNaN(seconds) || seconds < 0) return '0:00';
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            
            if (hours > 0) {
                return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            return `${minutes}:${secs.toString().padStart(2, '0')}`;
        }

        // Animate count from current to target number
        function animateStoryCount(targetCount) {
            const introElement = document.querySelector('.intro');
            if (!introElement) return;

            // Cancel any existing animation
            if (countAnimationId !== null) {
                cancelAnimationFrame(countAnimationId);
            }

            // Get current displayed count
            const currentText = introElement.textContent;
            const match = currentText.match(/(\d+)\s+stories/);
            const startCount = match ? parseInt(match[1], 10) : 0;
            
            // If already at target, no need to animate
            if (startCount === targetCount) {
                introElement.textContent = `${targetCount} stories worth listening.`;
                return;
            }

            currentTargetCount = targetCount;
            const duration = 800; // Faster animation duration in milliseconds
            const startTime = performance.now();

            function updateCount(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Easing function for smooth animation (ease-out)
                const easeOut = 1 - Math.pow(1 - progress, 3);
                const currentCount = Math.floor(startCount + (targetCount - startCount) * easeOut);
                
                introElement.textContent = `${currentCount} stories worth listening.`;
                
                if (progress < 1) {
                    countAnimationId = requestAnimationFrame(updateCount);
                } else {
                    // Ensure final count is exact
                    introElement.textContent = `${targetCount} stories worth listening.`;
                    countAnimationId = null;
                }
            }

            countAnimationId = requestAnimationFrame(updateCount);
        }

        // Initialize audio player
        function initAudioPlayer(audioUrl) {
            const audioElement = document.getElementById('audioElement');
            const audioPlayer = document.getElementById('modalAudioPlayer');
            const playPauseBtn = document.getElementById('audioPlayPause');
            const playIcon = playPauseBtn.querySelector('.play-icon');
            const pauseIcon = playPauseBtn.querySelector('.pause-icon');
            const progressFilled = document.getElementById('audioProgressFilled');
            const timeCurrent = document.getElementById('audioTimeCurrent');
            const timeDuration = document.getElementById('audioTimeDuration');
            const audioError = document.getElementById('audioError');

            // Reset state
            audioError.style.display = 'none';
            audioPlayer.classList.remove('audio-loading');
            playIcon.style.display = 'inline';
            pauseIcon.style.display = 'none';
            playPauseBtn.classList.remove('playing');
            progressFilled.style.width = '0%';
            timeCurrent.textContent = '0:00';
            timeDuration.textContent = '0:00';

            if (!audioUrl) {
                audioPlayer.style.display = 'none';
                return;
            }

            // Set audio source
            audioElement.src = audioUrl;
            audioPlayer.style.display = 'block';
            currentAudio = audioElement;

            // Load metadata
            audioElement.load();

            // Handle metadata loaded
            audioElement.addEventListener('loadedmetadata', () => {
                const duration = audioElement.duration;
                if (isFinite(duration)) {
                    timeDuration.textContent = formatTime(duration);
                }
            });

            // Handle time updates
            audioElement.addEventListener('timeupdate', () => {
                const current = audioElement.currentTime;
                const duration = audioElement.duration;
                
                if (isFinite(duration) && duration > 0) {
                    const progress = (current / duration) * 100;
                    progressFilled.style.width = `${progress}%`;
                    timeCurrent.textContent = formatTime(current);
                }
            });

            // Handle play/pause
            audioElement.addEventListener('play', () => {
                playIcon.style.display = 'none';
                pauseIcon.style.display = 'inline';
                playPauseBtn.classList.add('playing');
            });

            audioElement.addEventListener('pause', () => {
                playIcon.style.display = 'inline';
                pauseIcon.style.display = 'none';
                playPauseBtn.classList.remove('playing');
            });

            // Handle errors
            audioElement.addEventListener('error', () => {
                audioError.style.display = 'block';
                audioPlayer.classList.remove('audio-loading');
                playPauseBtn.disabled = true;
            });

            // Handle loading
            audioElement.addEventListener('loadstart', () => {
                audioPlayer.classList.add('audio-loading');
            });

            audioElement.addEventListener('canplay', () => {
                audioPlayer.classList.remove('audio-loading');
            });
        }

        // Handle play/pause button click
        function handleAudioPlayPause() {
            const audioElement = document.getElementById('audioElement');
            if (!audioElement || !audioElement.src) return;

            if (audioElement.paused) {
                audioElement.play().catch(err => {
                    console.error('Error playing audio:', err);
                    document.getElementById('audioError').style.display = 'block';
                });
            } else {
                audioElement.pause();
            }
        }

        // Handle progress bar click (seeking)
        function handleProgressBarClick(event) {
            const audioElement = document.getElementById('audioElement');
            const progressBar = document.getElementById('audioProgressBar');
            
            if (!audioElement || !audioElement.src || audioElement.readyState === 0) return;

            const rect = progressBar.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const percentage = clickX / rect.width;
            const duration = audioElement.duration;
            
            if (isFinite(duration) && duration > 0) {
                audioElement.currentTime = percentage * duration;
            }
        }

        // Cleanup audio when modal closes
        function cleanupAudio() {
            const audioElement = document.getElementById('audioElement');
            if (audioElement) {
                audioElement.pause();
                audioElement.src = '';
                audioElement.load();
            }
            currentAudio = null;
        }

        // Open story modal
        function openStoryModal(episode) {
            const modal = document.getElementById('storyModal');
            const modalImage = document.getElementById('modalImage');
            const modalCategory = document.getElementById('modalCategory');
            const modalTitle = document.getElementById('modalTitle');
            const modalMeta = document.getElementById('modalMeta');
            const modalDescription = document.getElementById('modalDescription');
            const modalTags = document.getElementById('modalTags');
            const modalDate = document.getElementById('modalDate');

            // Populate modal with episode data
            modalImage.src = episode.coverImage || '/images/icon.webp';
            modalImage.alt = episode.title;
            
            if (episode.category) {
                modalCategory.textContent = episode.category.toUpperCase();
                modalCategory.style.display = 'inline-block';
            } else {
                modalCategory.style.display = 'none';
            }
            
            modalTitle.textContent = episode.title;
            
            // Build meta information
            let metaHTML = '';
            if (episode.episodeNumber) {
                metaHTML += `<div class="modal-meta-item"><strong>Episode</strong> ${episode.episodeNumber}</div>`;
            }
            if (episode.duration) {
                const formattedDuration = formatDuration(episode.duration);
                if (formattedDuration) {
                    metaHTML += `<div class="modal-meta-item"><strong>Duration</strong> ${formattedDuration}</div>`;
                }
            }
            if (episode.host) {
                metaHTML += `<div class="modal-meta-item"><strong>Host</strong> ${episode.host}</div>`;
            }
            modalMeta.innerHTML = metaHTML || '';
            modalMeta.style.display = metaHTML ? 'flex' : 'none';
            
            // Use fullDescription if available, otherwise use description
            const descriptionText = episode.fullDescription || episode.description || 'No description available.';
            modalDescription.textContent = descriptionText;
            
            // Display tags if available
            if (episode.tags && Array.isArray(episode.tags) && episode.tags.length > 0) {
                modalTags.innerHTML = episode.tags.map(tag => 
                    `<span class="modal-tag">${tag.toUpperCase()}</span>`
                ).join('');
                modalTags.style.display = 'flex';
            } else {
                modalTags.innerHTML = '';
                modalTags.style.display = 'none';
            }
            
            // Initialize audio player if audio URL is available
            initAudioPlayer(episode.audioUrl || null);
            
            modalDate.textContent = formatDate(episode.createdAt);

            // Update URL without page reload
            window.history.pushState({ episodeId: episode.id }, '', `/episode/${episode.id}`);
            currentEpisodeId = episode.id;

            // Update meta tags for social sharing
            updateMetaTags(episode);

            // Show modal
            modal.classList.add('open');
            document.body.classList.add('modal-open');
        }

        // Close story modal
        function closeStoryModal() {
            cleanupAudio();
            const modal = document.getElementById('storyModal');
            modal.classList.remove('open');
            document.body.classList.remove('modal-open');
            
            // Update URL to home
            window.history.pushState({ view: 'gallery' }, '', '/');
            currentEpisodeId = null;
            
            // Reset meta tags
            resetMetaTags();
        }

        // Initialize modal event listeners
        function initModal() {
            const modal = document.getElementById('storyModal');
            const closeButton = document.getElementById('modalClose');
            const playPauseBtn = document.getElementById('audioPlayPause');
            const progressBar = document.getElementById('audioProgressBar');

            // Close button click
            closeButton.addEventListener('click', (e) => {
                e.stopPropagation();
                closeStoryModal();
            });

            // Backdrop click (close when clicking outside modal content)
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    closeStoryModal();
                }
            });

            // ESC key to close
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && modal.classList.contains('open')) {
                    closeStoryModal();
                }
            });

            // Audio player controls
            if (playPauseBtn) {
                playPauseBtn.addEventListener('click', handleAudioPlayPause);
            }

            if (progressBar) {
                progressBar.addEventListener('click', handleProgressBarClick);
            }
        }

        // Initialize routing and share functionality
        function initRouting() {
            const shareBtn = document.getElementById('modalShareBtn');
            const headerLink = document.getElementById('headerLink');

            if (shareBtn) {
                shareBtn.addEventListener('click', handleShare);
                // Also add mousedown to ensure it works
                shareBtn.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                });
            } else {
                console.warn('Share button not found');
            }

            if (headerLink) {
                headerLink.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (currentEpisodeId) {
                        closeStoryModal();
                    }
                });
            }

            // Handle browser back/forward navigation
            window.addEventListener('popstate', async (e) => {
                const episodeId = e.state?.episodeId || getEpisodeIdFromUrl();
                if (episodeId) {
                    await openModalFromEpisodeId(episodeId);
                } else {
                    closeStoryModal();
                }
            });
        }

        // Open modal from episode ID (for URL routing)
        async function openModalFromEpisodeId(episodeId) {
            // Try to find episode in already loaded episodes
            let episode = episodes.find(ep => ep.id === episodeId);
            
            // If not found, fetch from API
            if (!episode) {
                try {
                    const response = await fetch(`/api/episodes/${episodeId}`);
                    const data = await response.json();
                    
                    if (!data.success || !data.data) {
                        // Episode not found - show error or redirect
                        window.history.replaceState({ view: 'gallery' }, '', '/');
                        return;
                    }
                    
                    episode = data.data;
                } catch (error) {
                    console.error('Error fetching episode:', error);
                    window.history.replaceState({ view: 'gallery' }, '', '/');
                    return;
                }
            }
            
            // Open modal with episode
            openStoryModal(episode);
        }

        // Filter and render episodes (initial render)
        function renderEpisodes(filter = 'all') {
            const grid = document.getElementById('collectionGrid');
            const isMobile = window.innerWidth <= 768;
            
            // Filter episodes based on selected filter
            let filteredEpisodes;
            if (filter === 'all') {
                filteredEpisodes = episodes;
            } else if (filter === 'new') {
                // Show episodes sorted by createdAt (newest first)
                filteredEpisodes = [...episodes].sort((a, b) => {
                    return new Date(b.createdAt) - new Date(a.createdAt);
                });
            } else if (filter === 'popular') {
                // For now, show most recent episodes as placeholder
                // TODO: Replace with actual popularity metric when available
                filteredEpisodes = [...episodes].sort((a, b) => {
                    return new Date(b.createdAt) - new Date(a.createdAt);
                }).slice(0, Math.ceil(episodes.length * 0.3)); // Top 30% most recent
            } else {
                // Filter by category
                filteredEpisodes = episodes.filter(ep => ep.category === filter);
            }

            // Filter for mobile (show only middle 3 of each 5)
            if (isMobile) {
                filteredEpisodes = filteredEpisodes.filter((_, index) => {
                    const episodeIndex = index % 5;
                    return episodeIndex === 1 || episodeIndex === 2 || episodeIndex === 3;
                });
            }

            // Store old scroll distance for smooth transition
            const oldScrollDistance = scrollDistance;

            // Hide loading spinner
            const loadingSpinner = document.getElementById('loadingSpinner');
            if (loadingSpinner) {
                loadingSpinner.style.display = 'none';
            }

            grid.innerHTML = '';

            if (filteredEpisodes.length === 0) {
                grid.innerHTML = '<div class="loading">No episodes available</div>';
                scrollDistance = 0;
                scrollPosition = 0;
                updateTagStates(filter);
                return;
            }

            // Create first set
            filteredEpisodes.forEach(ep => grid.appendChild(createEpisodeCard(ep)));

            // Measure set width
            const setWidth = grid.scrollWidth;

            // Create 3 more sets for seamless looping
            for (let i = 0; i < 3; i++) {
                filteredEpisodes.forEach(ep => grid.appendChild(createEpisodeCard(ep)));
            }

            // Update scroll distance
            scrollDistance = setWidth;
            
            // Maintain scroll position relative to new distance for smooth transition
            if (oldScrollDistance > 0 && scrollDistance > 0) {
                const progress = scrollPosition / oldScrollDistance;
                scrollPosition = (progress * scrollDistance) % scrollDistance;
            } else {
                scrollPosition = 0;
            }
            
            // Update tag states
            updateTagStates(filter);
            
            // Ensure animation is running
            startAnimation();
        }

        // Update tag states based on active filter
        function updateTagStates(activeFilter) {
            const tags = document.querySelectorAll('.category-tag');
            tags.forEach(tag => {
                const tagCategory = tag.getAttribute('data-category');
                tag.classList.remove('active', 'inactive');
                
                if (activeFilter === 'all') {
                    // No filter active, all tags normal
                    tag.classList.remove('inactive');
                } else if (tagCategory === activeFilter) {
                    // This tag is active
                    tag.classList.add('active');
                } else {
                    // Other tags should fade
                    tag.classList.add('inactive');
                }
            });
        }

        // Initialize category tags with click handlers
        function initFilters(categories) {
            const filtersContainer = document.getElementById('filters');
            filtersContainer.innerHTML = '';

            // Create special filter tags (new and popular)
            const specialFilters = [
                { id: 'new', label: 'NEW' },
                { id: 'popular', label: 'POPULAR' }
            ];

            specialFilters.forEach(filter => {
                const tag = document.createElement('button');
                tag.className = 'category-tag';
                tag.textContent = filter.label;
                tag.setAttribute('data-category', filter.id);
                tag.setAttribute('type', 'button');
                tag.setAttribute('aria-label', `Filter by ${filter.label}`);
                
                // Add click handler
                tag.addEventListener('click', () => {
                    handleFilterClick(filter.id);
                });
                
                filtersContainer.appendChild(tag);
            });

            // Create category tags
            categories.forEach(category => {
                const tag = document.createElement('button');
                tag.className = 'category-tag';
                tag.textContent = category.toUpperCase();
                tag.setAttribute('data-category', category);
                tag.setAttribute('type', 'button');
                tag.setAttribute('aria-label', `Filter by ${category}`);
                
                // Add click handler
                tag.addEventListener('click', () => {
                    handleFilterClick(category);
                });
                
                filtersContainer.appendChild(tag);
            });
        }

        // Handle filter tag click
        function handleFilterClick(category) {
            // Toggle: if clicking the same filter, turn it off
            if (activeFilter === category) {
                activeFilter = 'all';
            } else {
                activeFilter = category;
            }
            
            // Update tag states
            updateTagStates(activeFilter);
            
            // Re-render episodes with the new filter
            // This ensures consistency and proper mobile filtering
            renderEpisodes(activeFilter);
        }

        // URL Routing Functions
        function getEpisodeIdFromUrl() {
            const match = window.location.pathname.match(/^\/episode\/([^\/]+)$/);
            return match ? match[1] : null;
        }

        // Meta Tags Functions
        function updateMetaTags(episode) {
            const baseUrl = window.location.origin;
            const episodeUrl = `${baseUrl}/episode/${episode.id}`;
            // Use dynamic OG image endpoint that includes cover image + title/description
            const ogImageUrl = `${baseUrl}/api/og-image/${episode.id}`;
            const description = episode.fullDescription || episode.description || 'Stories worth listening.';

            updateMetaTag('property', 'og:title', episode.title);
            updateMetaTag('property', 'og:description', description);
            updateMetaTag('property', 'og:image', ogImageUrl);
            updateMetaTag('property', 'og:url', episodeUrl);
            updateMetaTag('property', 'og:type', 'article');
            
            updateMetaTag('name', 'twitter:card', 'summary_large_image');
            updateMetaTag('name', 'twitter:title', episode.title);
            updateMetaTag('name', 'twitter:description', description);
            updateMetaTag('name', 'twitter:image', ogImageUrl);
            updateMetaTag('name', 'twitter:url', episodeUrl);
            
            document.title = `${episode.title} | Angle`;
        }

        function updateMetaTag(attr, value, content) {
            let tag = document.querySelector(`meta[${attr}="${value}"]`);
            if (!tag) {
                tag = document.createElement('meta');
                tag.setAttribute(attr, value);
                document.head.appendChild(tag);
            }
            tag.setAttribute('content', content);
        }

        function resetMetaTags() {
            const baseUrl = window.location.origin;
            updateMetaTag('property', 'og:title', 'Angle');
            updateMetaTag('property', 'og:description', 'Stories worth listening.');
            updateMetaTag('property', 'og:image', `${baseUrl}/api/og-image`);
            updateMetaTag('property', 'og:url', baseUrl);
            updateMetaTag('property', 'og:type', 'website');
            
            updateMetaTag('name', 'twitter:card', 'summary_large_image');
            updateMetaTag('name', 'twitter:title', 'Angle');
            updateMetaTag('name', 'twitter:description', 'Stories worth listening.');
            updateMetaTag('name', 'twitter:image', `${baseUrl}/api/og-image`);
            updateMetaTag('name', 'twitter:url', baseUrl);
            
            document.title = 'Angle';
        }

        // Share Functionality
        function showShareToast() {
            let toast = document.getElementById('shareToast');
            if (!toast) {
                toast = document.createElement('div');
                toast.id = 'shareToast';
                toast.className = 'share-toast';
                toast.textContent = 'Link copied!';
                document.body.appendChild(toast);
            }
            
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 2000);
        }

        async function handleShare(e) {
            if (e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            console.log('Share button clicked');
            const url = window.location.href;
            const title = document.title;
            
            console.log('Sharing URL:', url);
            
            // Try native share API first (mobile)
            if (navigator.share) {
                try {
                    await navigator.share({
                        title: title,
                        text: title,
                        url: url
                    });
                    showShareToast();
                    return;
                } catch (err) {
                    // User cancelled (error code 20) - don't show error
                    if (err.name === 'AbortError' || err.code === 20) {
                        return;
                    }
                    // Other error - fall through to clipboard
                    console.log('Native share failed, falling back to clipboard:', err);
                }
            }
            
            // Fall back to clipboard
            try {
                // Check if clipboard API is available
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(url);
                    showShareToast();
                } else {
                    throw new Error('Clipboard API not available');
                }
            } catch (err) {
                console.error('Clipboard API failed, using fallback:', err);
                // Fallback for older browsers or when clipboard API fails
                try {
                    const textArea = document.createElement('textarea');
                    textArea.value = url;
                    textArea.style.position = 'fixed';
                    textArea.style.top = '0';
                    textArea.style.left = '0';
                    textArea.style.width = '2em';
                    textArea.style.height = '2em';
                    textArea.style.padding = '0';
                    textArea.style.border = 'none';
                    textArea.style.outline = 'none';
                    textArea.style.boxShadow = 'none';
                    textArea.style.background = 'transparent';
                    textArea.style.opacity = '0';
                    textArea.readOnly = true;
                    
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    
                    const successful = document.execCommand('copy');
                    document.body.removeChild(textArea);
                    
                    if (successful) {
                        showShareToast();
                    } else {
                        console.error('execCommand copy failed');
                        alert('Failed to copy link. Please copy manually: ' + url);
                    }
                } catch (e) {
                    console.error('Fallback copy failed:', e);
                    alert('Failed to copy link. Please copy manually: ' + url);
                }
            }
        }

        // Fetch and initialize
        async function init() {
            // Check if we're on an episode URL
            const episodeId = getEpisodeIdFromUrl();
            
            // Always load episodes in background
            try {
                // Fetch categories and episodes in parallel
                const [categoriesRes, episodesRes] = await Promise.all([
                    fetch('/api/categories'),
                    fetch('/api/episodes')
                ]);

                const categoriesData = await categoriesRes.json();
                const episodesData = await episodesRes.json();

                if (categoriesData.success) {
                    initFilters(categoriesData.data);
                }

                if (episodesData.success) {
                    episodes = shuffleArray(episodesData.data);
                    // Update to actual count (will smoothly transition from current count)
                    if (episodes.length > 0) {
                        animateStoryCount(episodes.length);
                    }
                    
                    // If we're on an episode URL, open modal; otherwise show gallery
                    if (episodeId) {
                        await openModalFromEpisodeId(episodeId);
                    } else {
                        renderEpisodes();
                    }
                } else {
                    const loadingSpinner = document.getElementById('loadingSpinner');
                    if (loadingSpinner) {
                        loadingSpinner.style.display = 'none';
                    }
                    if (!episodeId) {
                        document.getElementById('collectionGrid').innerHTML = 
                            '<div class="loading">Failed to load episodes</div>';
                    }
                }
            } catch (error) {
                console.error('Error initializing:', error);
                const loadingSpinner = document.getElementById('loadingSpinner');
                if (loadingSpinner) {
                    loadingSpinner.style.display = 'none';
                }
                
                // If we're on an episode URL, try to open modal anyway
                if (episodeId) {
                    await openModalFromEpisodeId(episodeId);
                } else {
                    document.getElementById('collectionGrid').innerHTML = 
                        '<div class="loading">Failed to load episodes</div>';
                }
            }
        }

        // Re-render on resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // Maintain relative position on resize
                const oldDistance = scrollDistance;
                renderEpisodes(activeFilter);
                // Adjust position if distance changed
                if (oldDistance > 0 && scrollDistance > 0) {
                    const progress = scrollPosition / oldDistance;
                    scrollPosition = (progress * scrollDistance) % scrollDistance;
                    const grid = document.getElementById('collectionGrid');
                    grid.style.transform = `translateX(-${scrollPosition}px)`;
                }
            }, 250);
        });

        // Initialize modal and routing on page load
        initModal();
        initRouting();

        // Start counting immediately (before data loads)
        // Estimate a reasonable starting count - will update to actual count when data loads
        animateStoryCount(144); // Start counting to a reasonable estimate

        // Start
        init();
    </script>
</body>
</html>
